<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基础篇 | 捞月亮の小北</title><meta name="author" content="捞月亮の小北"><meta name="copyright" content="捞月亮の小北"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、 Java 语言有哪些特点 展开答案                               1、简单易学、有丰富的类库2、面向对象（ Java 最重要的特性，让程序耦合度更低，内聚性更高）3、与平台无关性（ JVM 是 Java 跨平台使用的根本）4、可靠安全5、支持多线程                              2、面向对象和面向过程的区别 展开答案">
<meta property="og:type" content="article">
<meta property="og:title" content="基础篇">
<meta property="og:url" content="https://lunanorth.github.io/posts/6314.html">
<meta property="og:site_name" content="捞月亮の小北">
<meta property="og:description" content="1、 Java 语言有哪些特点 展开答案                               1、简单易学、有丰富的类库2、面向对象（ Java 最重要的特性，让程序耦合度更低，内聚性更高）3、与平台无关性（ JVM 是 Java 跨平台使用的根本）4、可靠安全5、支持多线程                              2、面向对象和面向过程的区别 展开答案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/wallhaven-jx793p.jpg">
<meta property="article:published_time" content="2024-08-23T03:18:02.000Z">
<meta property="article:modified_time" content="2024-08-23T07:18:52.255Z">
<meta property="article:author" content="捞月亮の小北">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/wallhaven-jx793p.jpg"><link rel="shortcut icon" href="/img/moon.png"><link rel="canonical" href="https://lunanorth.github.io/posts/6314.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基础篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-23 15:18:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/navigation.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw far fa-paper-plane"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-comments"></i><span> 碎碎念</span></a></div><div class="menus_item"><a class="site-page" href="/collect/"><i class="fa-fw fa fa-book"></i><span> 藏宝阁</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/wallhaven-jx793p.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="捞月亮の小北"><img class="site-icon" src="/img/moon.png"/><span class="site-name">捞月亮の小北</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw far fa-paper-plane"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-comments"></i><span> 碎碎念</span></a></div><div class="menus_item"><a class="site-page" href="/collect/"><i class="fa-fw fa fa-book"></i><span> 藏宝阁</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基础篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-23T03:18:02.000Z" title="发表于 2024-08-23 11:18:02">2024-08-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-23T07:18:52.255Z" title="更新于 2024-08-23 15:18:52">2024-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">面试总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基础篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1、-Java-语言有哪些特点"><a href="#1、-Java-语言有哪些特点" class="headerlink" title="1、 Java 语言有哪些特点"></a><strong>1</strong>、 <strong>Java</strong> 语言有哪些特点</h3><details class="folding-tag" red><summary> 展开答案 </summary>
              <div class='content'>
              <p>1、简单易学、有丰富的类库</p><p>2、面向对象（ Java 最重要的特性，让程序耦合度更低，内聚性更高）</p><p>3、与平台无关性（ JVM 是 Java 跨平台使用的根本）</p><p>4、可靠安全</p><p>5、支持多线程 </p>
              </div>
            </details>
<h3 id="2、面向对象和面向过程的区别"><a href="#2、面向对象和面向过程的区别" class="headerlink" title="2、面向对象和面向过程的区别"></a><strong>2</strong>、面向对象和面向过程的区别</h3><details class="folding-tag" red><summary> 展开答案 </summary>
              <div class='content'>
              <p><strong>面向过程</strong>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p><p><strong>面向对象</strong>：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有 <strong>封装、继承、多态</strong> 的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。 </p>
              </div>
            </details>
<h3 id="3-、八种基本数据类型的大小，以及他们的封装类"><a href="#3-、八种基本数据类型的大小，以及他们的封装类" class="headerlink" title="3  、八种基本数据类型的大小，以及他们的封装类"></a><strong>3</strong>  <strong>、八种基本数据类型的大小，以及他们的封装类</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>基本类型</strong></th>
<th><strong>大小（字节）</strong></th>
<th><strong>默认值</strong></th>
<th><strong>封装类</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1</td>
<td>（ byte ）0</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>（ short ）0</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0 L</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0 f</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0 d</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>-</td>
<td>false</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>\u0000（ null ）</td>
<td>Character</td>
</tr>
</tbody>
</table>
</div>
<p>注：</p>
<ul>
<li>int 是基本数据类型，Integer 是 int 的封装类，是引用类型。int 默认值是0，而 Integer 默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li>
<li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</li>
</ul>
<p>虽然定义了 boolean 这种数据类型，但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java 语言表达式所操作的 boolean 值，在编译之后都使用 Java 虚拟机中的 int 数据类型来代替，而 boolean 数组将会被编码成 Java 虚拟机的 byte 数组，每个元素 boolean 元素占 8 位。这样我们可以得出 boolean 类型占了单独使用是 4 个字节，在数组中又是 1 个字</p>
<p>节。使用 int 的原因是，对于当下 32 位的处理器（ CPU ）来说，一次处理数据是 32 位（这里不是指的是 32 / 64 位系统，而是指 CPU 硬件层面），具有高效存取的特点。</p>
<h3 id="4、标识符的命名规则"><a href="#4、标识符的命名规则" class="headerlink" title="4、标识符的命名规则"></a><strong>4</strong>、标识符的命名规则</h3><p><strong>标识符的含义：</strong>  是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。</p>
<p><strong>命名规则：（硬性要求）</strong>  标识符可以包含英文字母，0 - 9 的数字，$ 以及_ 标识符不能以数字开头 标识符不是关键字</p>
<p><strong>命名规范：（非硬性要求）</strong>  类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 方法名规范：同变量名。</p>
<h3 id="5、instanceof-关键字的作用"><a href="#5、instanceof-关键字的作用" class="headerlink" title="5、instanceof 关键字的作用"></a><strong>5</strong>、instanceof <strong>关键字的作用</strong></h3><p>instanceof  严格来说是 Java 中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure>
<p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果 result 都返回 true，否则返回 false 。</p>
<p>注意：编译器会检查 obj 是否能转换成右边的 class 类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过 i 必须是引用类型，不能是基本类型</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//false ,在 JavaSE 规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。</span></span><br><span class="line">System.out.println(<span class="literal">null</span> <span class="keyword">instanceof</span> Object);</span><br></pre></td></tr></table></figure>
<h3 id="6、Java-自动装箱与拆箱"><a href="#6、Java-自动装箱与拆箱" class="headerlink" title="6、Java 自动装箱与拆箱"></a><strong>6</strong>、Java 自动装箱与拆箱</h3><p><strong>装箱就是自动将基本数据类型转换为包装器类型（ int —&gt; Integer ），调用方法：Integer 的 valueOf (int) 方法</strong></p>
<p><strong>拆箱就是自动将包装器类型转换为基本数据类型（ Integer —&gt; int），调用方法：Integer 的 intValue 方法</strong></p>
<p>在 Java SE5 之前，如果要生成一个数值为 10 的 Integer 对象，必须这样进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>而在从 Java SE5 开始就提供了自动装箱的特性，如果要生成一个数值为 10 的 Integer 对象，只需要这样就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>面试题 1 ： 以下代码会输出什么？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line"> 	<span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> 	<span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"> 	<span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line"> 	System.out.println(i1==i2);</span><br><span class="line"> 	System.out.println(i3==i4);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>为什么会出现这样的结果？输出结果表明 i1 和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对</p>
<p>象。此时只需一看源码便知究竟，下面这段代码是 Integer 的 valueOf 方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"> 	<span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"> 	<span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line"> 	<span class="keyword">else</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其中 IntegerCache 类的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"> 	<span class="comment">// high value may be configured by property</span></span><br><span class="line"> 	<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"> 	<span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line"> 	<span class="comment">// Use Long.decode here to avoid invoking methods that</span></span><br><span class="line"> 	<span class="comment">// require Integer&#x27;s autoboxing cache to be initialized</span></span><br><span class="line"> 	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Long.decode(integerCacheHighPropValue).intValue();</span><br><span class="line"> 	i = Math.max(i, <span class="number">127</span>);</span><br><span class="line"> 	<span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">	h = Math.min(i, Integer.MAX_VALUE - -low);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	high = h;</span><br><span class="line"> 	cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line"> 	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line"> 	cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从这2段代码可以看出，在通过 valueOf 方法创建 Integer 对象的时候，如果数值在 [-128,127] 之间，便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。</p>
<p>上面的代码中 i1 和 i2 的数值为 100 ，因此会直接从 cache 中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。</p>
<p><strong>面试题 2 ：以下代码输出什么运行结果：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line"> 	<span class="type">Double</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">100.0</span>;</span><br><span class="line"> 	<span class="type">Double</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">100.0</span>;</span><br><span class="line"> 	<span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">200.0</span>;</span><br><span class="line"> 	<span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">200.0</span>;</span><br><span class="line"> </span><br><span class="line"> 	System.out.println(i1==i2);</span><br><span class="line"> 	System.out.println(i3==i4);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>
<h3 id="7、-重载和重写的区别"><a href="#7、-重载和重写的区别" class="headerlink" title="7、 重载和重写的区别"></a><strong>7</strong>、 重载和重写的区别</h3><p><strong>重写 (Override)</strong></p>
<p>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> 	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 	<span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"> 	s.sayHello();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line"> 	System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line"> 	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 	System.out.println(<span class="string">&quot;hello by &quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重写 总结：</strong>  1.发生在父类与子类之间 2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 3.访问修饰符的限制一定要大于被重写方法的访问修饰符（ public &gt; protected &gt; default &gt; private ) 4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</p>
<p><strong>重载（ Overload ）</strong></p>
<p>在一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<strong>不能通过返回类型是否相同来判断重载</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> 		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 		<span class="type">Father</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"> 		s.sayHello();</span><br><span class="line"> 		s.sayHello(<span class="string">&quot;wintershii&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + name);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重载 总结：</strong>  1.重载 Overload 是一个类中多态性的一种表现 2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</p>
<h3 id="8、equals-与-的区别"><a href="#8、equals-与-的区别" class="headerlink" title="8、equals 与 == 的区别"></a>8、equals 与 == 的区别</h3><p> <strong>==</strong>   <strong>：</strong></p>
<p>== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p>
<p>1、比较的是操作符两端的操作数是否是同一个对象。 2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。 3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为 true，如： int a = 10 与 long b = 10 L 与 double c = 10.0 都是相同的（为true），因为他们都指向地址为 10 的堆。</p>
<p><strong>equals</strong>：</p>
<p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是 == 的判断。</p>
<p>总结：</p>
<p>所有比较是否相等时，都是用 equals 并且在对常量相比较时，把常量写在前面，因为使用 object 的 equals object 可能为 null 则空指针</p>
<p>在阿里的代码规范中只使用 equals，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用 “==” ，替换成 equals</p>
<h3 id="9、Hashcode-的作用"><a href="#9、Hashcode-的作用" class="headerlink" title="9、Hashcode 的作用"></a><strong>9、Hashcode 的作用</strong></h3><p>java 的集合有两类，一类是 List ，还有一类是 Set 。前者有序可重复，后者无序不重复。当我们在 set 中插入的时候怎么判断是否已经存在该元素呢，可以通过 equals 方法。但是如果元素太多，用这样的方法就会比较满。</p>
<p>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。</p>
<p>hashCode 方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用 equals 方法的次数就大大降低了，几乎只需要一两次。</p>
<h3 id="10、String、StringBuffer-和-StringBuilder-的区别是什么"><a href="#10、String、StringBuffer-和-StringBuilder-的区别是什么" class="headerlink" title="10、String、StringBuffer 和 StringBuilder 的区别是什么?"></a>10、String、StringBuffer 和 StringBuilder 的区别是什么?</h3><p>String 是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个 final 类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对 String 的操作都会生成新的 String 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];<span class="comment">//dk1.8 及以前 String 底层使用的是 char 数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;<span class="comment">//jdk 1.9 及以后使用的是 byte 数组</span></span><br></pre></td></tr></table></figure>
<p><strong>jdk1.8 及以前 String 底层使用的是 char 数组，jdk 1.9 及以后使用的是 byte 数组。</strong></p>
<p>每次 + 操作 ： 隐式在堆上 new 了一个跟原字符串相同的 StringBuilder 对象，再调用 append 方法拼接 + 后面的字符。</p>
<p>StringBuffer 和 StringBuilder 他们两都继承了 AbstractStringBuilder 抽象类，从 AbstractStringBuilder 抽象类中我们可以看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 基于1.8</span></span><br><span class="line"><span class="comment">* The value is used for character storage.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span>[] value;</span><br></pre></td></tr></table></figure>
<p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用 StringBuffer 和 StringBuilder 来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h3 id="11、ArrayList-和-linkedList-的区别"><a href="#11、ArrayList-和-linkedList-的区别" class="headerlink" title="11、ArrayList 和 linkedList 的区别"></a>11、ArrayList 和 linkedList 的区别</h3><p><strong>ArrayList</strong></p>
<ul>
<li><strong>优点</strong>：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</li>
<li><strong>缺点</strong>：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</li>
</ul>
<p><strong>LinkedList</strong></p>
<ul>
<li><strong>优点</strong>：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</li>
<li><strong>缺点</strong>：因为 LinkedList 要移动指针，所以查询操作性能比较低。</li>
</ul>
<p><strong>适用场景分析</strong></p>
<ul>
<li>当需要对数据进行对随机访问的时候，选用 ArrayList。</li>
<li>当需要对数据进行多次增加删除修改时，采用 LinkedList。</li>
</ul>
<p>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList。</p>
<p>当然，绝大数业务的场景下，使用 ArrayList 就够了，但需要注意避免 ArrayList 的扩容，以及非顺序的插入。</p>
<p><strong>Array （数组）是基于索引（index）的数据结构，它使用索引在数组中搜索和读取数据是很快的。</strong></p>
<p>Array 获取数据的时间复杂度是 O ( 1 ) ,但是要删除数据却是开销很大，因为这需要重排数组中的所有数据（因为删除数据以后, 需要把后面所有的数据前移）</p>
<p><strong>缺点：</strong> 数组初始化必须指定初始化的长度, 否则报错</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];<span class="comment">//推介使用int[] 这种方式初始化</span></span><br><span class="line"><span class="type">int</span> c[] = &#123;<span class="number">23</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">78</span>&#125;;<span class="comment">//长度：4，索引范围：[0,3]</span></span><br></pre></td></tr></table></figure>
<p><strong>List 是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承 Collection。</strong></p>
<p><strong>List有两个重要的实现类：ArrayList 和 LinkedList</strong></p>
<p><strong>ArrayList:</strong>  <strong>可以看作是能够自动增长容量的数组</strong></p>
<p><strong>ArrayList 的 toArray 方法返回一个数组</strong></p>
<p><strong>ArrayList 的 asList 方法返回一个列表</strong></p>
<p>ArrayList底层的实现是 Array, 数组扩容实现</p>
<p><strong>LinkList 是一个双链表 ，在添加和删除元素时具有比 ArrayList 更好的性能；但在 get 与 set 方面弱于ArrayList。当然，这些对比都是指数据量很大或者操作很频繁。</strong></p>
<h3 id="12、HashMap-和-HashTable-的区别"><a href="#12、HashMap-和-HashTable-的区别" class="headerlink" title="12、HashMap 和 HashTable 的区别"></a>12、HashMap 和 HashTable 的区别</h3><p>HashTable 是 java 一开始发布时就提供的键值映射的数据结构，而 HashMap 产生于 JDK 1.2。虽然 HashTable 比 HashMap 出现的早一些，<strong>但是现在 HashTable 基本上已经被弃用了</strong>。而 HashMap 已经成为应用最为广泛的一种数据类型了。</p>
<h4 id="1、两者父类不同"><a href="#1、两者父类不同" class="headerlink" title="1、两者父类不同"></a>1、两者父类不同</h4><p>HashMap 是继承自 AbstractMap 类，而 HashTable 是继承自 Dictionary 类。不过它们同时实现了 map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</p>
<h4 id="2、对外提供的接口不同"><a href="#2、对外提供的接口不同" class="headerlink" title="2、对外提供的接口不同"></a>2、对外提供的接口不同</h4><p>HashTable 比 HashMap 多提供了 elments() 和 contains() 两个方法。elments() 方法继承自 HashTable 的父类 Dictionnary。elements() 方法用于返回此 HashTable 中的 value 的枚举。</p>
<p>contains() 方法判断该 HashTable 是否包含传入的 value。它的作用与 containsValue() 一致。事实上，contansValue() 就只是调用了一下 contains() 方法。</p>
<h4 id="3、对-null-的支持不同"><a href="#3、对-null-的支持不同" class="headerlink" title="3、对 null 的支持不同"></a>3、对 null 的支持不同</h4><p>Hashtable：key 和 value 都不能为 null。</p>
<p>HashMap：key 可以为 null，但是这样的 key 只能有一个，因为必须保证 key 的唯一性；可以有多个 key 值对应的 value 为 null。</p>
<h4 id="4、安全性不同"><a href="#4、安全性不同" class="headerlink" title="4、安全性不同"></a>4、安全性不同</h4><p>HashMap 是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。</p>
<p>Hashtable 是线程安全的，它的每个方法上都有 synchronized  关键字，因此可直接用于多线程中。</p>
<p>虽然 HashMap 是线程不安全的，但是它的效率远远高于 Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的 ConcurrentHashMap 。</p>
<p>ConcurrentHashMap 虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为 ConcurrentHashMap 使用了分段锁，并不对整个数据进行锁定。</p>
<p><strong>第二种答案：</strong></p>
<ol>
<li>出生的版本不一样，Hashtable 出生于 Java 发布的第一版本 JDK 1.0，HashMap 出生于 JDK 1.2。</li>
<li>都实现了 Map、Cloneable、Serializable（ 当前 JDK 版本 1.8 ）。</li>
<li>HashMap 继承的是 AbstractMap，并且 AbstractMap 也实现了 Map 接口。Hashtable 继承 Dictionary。</li>
<li>Hashtable 中大部分 public 修饰普通方法都是 synchronized 字段修饰的，是线程安全的，HashMap 是非线程安全的。</li>
<li>Hashtable 的 key 不能为 null，value 也不能为 null，这个可以从 Hashtable 源码中的 put 方法看到，判断如果 value 为 null 就直接抛出空指针异常，在 put 方法中计算 key 的 hash 值之前并没有判断 key 为 null 的情况，那说明，这时候如果 key 为空，照样会抛出空指针异常。</li>
<li>HashMap 的 key 和 value 都可以为 null。在计算 hash 值的时候，有判断，如果 key==null ，则其 hash=0 ；至于 value 是否为 null，根本没有判断过。</li>
<li>Hashtable 直接使用对象的 hash 值。hash 值是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</li>
<li>Hashtable、HashMap 都使用了 Iterator。而由于历史原因，Hashtable 还使用了 Enumeration 的方式。</li>
<li><p>默认情况下，初始容量不同，Hashtable 的初始长度是 11，之后每次扩充容量变为之前的 2n+1（n 为上一次的长度）而 HashMap 的初始长度为 16，之后每次扩充变为原来的两倍。</p>
<p> 另外在 Hashtable 源码注释中有这么一句话：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hashtable is synchronized. If a thread-safe implementation is not needed, it is</span><br><span class="line">recommended to use HashMap in place of Hashtable . If a thread-safe highlyconcurrent implementation is desired, then it is recommended to use</span><br><span class="line">ConcurrentHashMap in place of Hashtable.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>大致意思：Hashtable 是线程安全，推荐使用 HashMap 代替 Hashtable；如果需要线程安全高并发的话，推荐使用 ConcurrentHashMap 代替 Hashtable。</p>
<p>这个回答完了，面试官可能会继续问：HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？</p>
<p>这里最好的选择就是 ConcurrentHashMap 了，但面试官肯定会叫你继续说一下 ConcurrentHashMap 数据结构以及底层原理等。</p>
<p><strong>拓展：什么是分段锁？</strong></p>
<p>ConcurrentHashMap 中的分段锁称为 Segment，它的内部结构是维护一个 HashEntry 数组，同时 Segment 还继承了 ReentrantLock。</p>
<p>当需要 put 元素的时候，并不是对整个 ConcurrentHashMap 进行加锁，而是先通过 hashcode 来判断它放在哪一个分段中，然后对该分段进行加锁。所以当多线程 put 的时候，只要不是放在同一个分段中，就可以实现并行的插入。分段锁的设计目的就是为了细化锁的粒度，从而提高并发能力。</p>
<p>jdk 1.8 中的 ConcurrentHashMap 中废弃了 Segment 锁，直接使用了数组元素，数组中的每个元素都可以作为一个锁。在元素中没有值的情况下，可以直接通过 CAS 操作来设值，同时保证并发安全；如果元素里面已经存在值的话，那么就使用 synchronized 关键字对元素加锁，再进行之后的 hash 冲突处理。jdk1.8 的 ConcurrentHashMap 加锁粒度比 jdk 1.7 里的 Segment 来加锁粒度更细，并发性能更好。</p>
<h4 id="5、初始容量大小和每次扩充容量大小不同"><a href="#5、初始容量大小和每次扩充容量大小不同" class="headerlink" title="5、初始容量大小和每次扩充容量大小不同"></a>5、初始容量大小和每次扩充容量大小不同</h4><p>HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75</p>
<ul>
<li>HashMap 每次扩充，容量变为原来的 2 倍（ 2 n ）；</li>
<li>HashTable 每次扩充，容量会变为原来的 2 倍 + 1（ 2 n + 1 ）；</li>
</ul>
<p>下面给出 HashMap 中的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<p><strong>拓展：什么是负载因子？</strong></p>
<p>负载因子 loadFactor = 哈希表的有效元素个数 / 哈希表长度</p>
<p>这个值越大就说明冲突越严重一些<br>这个值越小说明冲突越小，数组利用率越低<br>扩容：采用整表扩容的方式什么时候需要对数组扩容？</p>
<p>扩容与否就根据负载因子来决定，当数组长度 * 负载因子 &lt;=  有效元素个数就需要扩容</p>
<p>HashMap中的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a power of two size for the given target capacity.</span><br><span class="line"> */</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、计算-hash-值的方法不同"><a href="#6、计算-hash-值的方法不同" class="headerlink" title="6、计算 hash 值的方法不同"></a>6、计算 hash 值的方法不同</h4><p>为了得到元素的位置，首先需要根据元素的 KEY 计算出一个 hash 值，然后再用这个 hash 值来计算得到最终的位置。</p>
<p>Hashtable 中 hash 的计算方法为：直接使用对象的 hashCode()。<br>HashMap 中 hash 的计算方法为：key 的 hash 值高 16 位不变，低 16 位与高 16 位异或作为 key 最终的 hash 值。（h&gt;&gt;&gt;16，表示无符号右移 16 位，高位补 0 ）</p>
<p><strong>HashTable：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified &lt;code&gt;key&lt;/code&gt; to the specified</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;value&lt;/code&gt; in this hashtable. Neither the key nor the</span></span><br><span class="line"><span class="comment"> * value can be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      key     the hashtable key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      value   the value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     the previous value of the specified key in this hashtable,</span></span><br><span class="line"><span class="comment"> *             or &lt;code&gt;null&lt;/code&gt; if it did not have one</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  NullPointerException  if the key or value is</span></span><br><span class="line"><span class="comment"> *               &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#equals(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #get(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashMap：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>拓展：什么是hashCode？</strong></p>
<p>hashCode 是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。</p>
<p><strong>两者为啥 hash 算法不一样？</strong></p>
<p>Hashtable 在计算元素的位置时使用除留余数法来获得存储的最终的位置，而除法运算是比较耗时的。</p>
<p>HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的倍数，这样在取模运算时，不需要做除法，只需要做位运算（左移一位就是乘以 2 ）。位运算比除法的效率要高很多。</p>
<p>HashMap 的效率虽然提高了，但是 hash 冲突却也增加了。因为它得出的 hash 值的低位相同的概率比较高。</p>
<p>为了解决这个问题，HashMap 重新根据 hashcode 计算 hash 值后，又将 hash 值无符号右移 16 位，使得运算出来所取得的位置分散到高低位中，从而减少了 hash 冲突。HashMap 中采取的这种简单位运算操作，不会把使用 2 的幂次方带来的效率提升给抵消掉。</p>
<h4 id="7-迭代器内部实现不同"><a href="#7-迭代器内部实现不同" class="headerlink" title="7. 迭代器内部实现不同"></a>7. 迭代器内部实现不同</h4><p>Hashtable、HashMap 都使用了 Iterator。Hashtable 还使用了 Enumeration 的方式 。</p>
<p>Hashtable中 的 Enumerator 类，实现了 Enumeration 接口和 Iterator 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A hashtable enumerator class.  This class implements both the</span></span><br><span class="line"><span class="comment"> * Enumeration and Iterator interfaces, but individual instances</span></span><br><span class="line"><span class="comment"> * can be created with the Iterator methods disabled.  This is necessary</span></span><br><span class="line"><span class="comment"> * to avoid unintentionally increasing the capabilities granted a user</span></span><br><span class="line"><span class="comment"> * by passing an Enumeration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Enumerator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Enumeration</span>&lt;T&gt;, Iterator&lt;T&gt; &#123;</span><br><span class="line">    Entry&lt;?,?&gt;[] table = Hashtable.<span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> table.length;</span><br><span class="line">    Entry&lt;?,?&gt; entry;</span><br><span class="line">    Entry&lt;?,?&gt; lastReturned;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether this Enumerator is serving as an Iterator</span></span><br><span class="line"><span class="comment">     * or an Enumeration.  (true -&gt; Iterator).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">     * Hashtable should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">     * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    Enumerator(<span class="type">int</span> type, <span class="type">boolean</span> iterator) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.iterator = iterator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasMoreElements</span><span class="params">()</span> &#123;</span><br><span class="line">        Entry&lt;?,?&gt; e = entry;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;</span><br><span class="line">        Entry&lt;?,?&gt;[] t = table;</span><br><span class="line">        <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line">        <span class="keyword">while</span> (e == <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e = t[--i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry = e;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">return</span> e != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">nextElement</span><span class="params">()</span> &#123;</span><br><span class="line">        Entry&lt;?,?&gt; et = entry;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;</span><br><span class="line">        Entry&lt;?,?&gt;[] t = table;</span><br><span class="line">        <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line">        <span class="keyword">while</span> (et == <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            et = t[--i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry = et;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">if</span> (et != <span class="literal">null</span>) &#123;</span><br><span class="line">            Entry&lt;?,?&gt; e = lastReturned = entry;</span><br><span class="line">            entry = e.next;</span><br><span class="line">            <span class="keyword">return</span> type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;Hashtable Enumerator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterator methods</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasMoreElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="keyword">return</span> nextElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!iterator)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Hashtable Enumerator&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(Hashtable.<span class="built_in">this</span>) &#123;</span><br><span class="line">            Entry&lt;?,?&gt;[] tab = Hashtable.<span class="built_in">this</span>.table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (lastReturned.hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">            <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="literal">null</span>; e != <span class="literal">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == lastReturned) &#123;</span><br><span class="line">                    modCount++;</span><br><span class="line">                    expectedModCount++;</span><br><span class="line">                    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">                        tab[index] = e.next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = e.next;</span><br><span class="line">                    count--;</span><br><span class="line">                    lastReturned = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap 中的 Iterator ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">  <span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">      Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">      <span class="type">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">      <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">      HashIterator() &#123;</span><br><span class="line">          expectedModCount = modCount;</span><br><span class="line">          Node&lt;K,V&gt;[] t = table;</span><br><span class="line">          current = next = <span class="literal">null</span>;</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">              <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">          Node&lt;K,V&gt;[] t;</span><br><span class="line">          Node&lt;K,V&gt; e = next;</span><br><span class="line">          <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">          <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">          <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">          Node&lt;K,V&gt; p = current;</span><br><span class="line">          <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">          <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">          current = <span class="literal">null</span>;</span><br><span class="line">          <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">          removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">          expectedModCount = modCount;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>拓展：JDK 8 之后，HashMap 和 Hashtable 的 Iterator 都有 fast-fail 机制。</strong></p>
<p>当有其它线程修改了 HashMap 的结构时，将会抛出 ConcurrentModificationException 异常。</p>
<p>注：结构修改是指改变 HashMap 中的映射数量或以其他方式修改其内部结构 (如，重新哈希，增加，删除，修改元素)。</p>
<p><strong>什么是 fast-fail 机制？</strong></p>
<p><img src="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/network-asset-1-1-20240823074440-3xmm3cy.png" alt="">​</p>
<p>例如，通常不允许一个线程在另一个线程迭代 Collection 时修改它。</p>
<p>通常，迭代的结果在这些情况下是没有定义的。如果检测到此行为，一些 Iterator 实现(包括JRE提供的所有通用集合实现)可能会选择抛出此异常。这样做的迭代器被称为快速失败迭代器，因为它们快速而干净地失败，而不是冒着在未来不确定的时间发生任意、不确定行为的风险。</p>
<p>迭代器中的 modCount 变量，类似于并发编程中的 CAS（Compare and Swap）技术。我们可以看到这个方法中，每次在发生增删改的时候都会出现 modCount++ 的动作。</p>
<p><img src="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/network-asset-1-2-20240823074441-3mr3hcn.png" alt="">​</p>
<p>而 modcount 可以理解为是当前 hashtable 的状态。每发生一次操作，状态就向前走一步。设置这个状态，主要是由于 hashtable 等容器类在迭代时，判断数据是否过时时使用的。尽管 hashtable 采用了原生的同步锁来保护数据安全。但是在出现迭代数据的时候，则无法保证边迭代，边正确操作。于是使用这个值来标记状态。一旦在迭代的过程中状态发生了改变，则会快速抛出一个异常，终止迭代行为。</p>
<h3 id="13、-Collection-包结构与-Collections-的区别"><a href="#13、-Collection-包结构与-Collections-的区别" class="headerlink" title="13、 Collection 包结构与 Collections 的区别"></a>13、 Collection 包结构与 Collections 的区别</h3><p>Collection 是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；</p>
<p>Collections 是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</p>
<h3 id="14、-Java-的四种引用，强弱软虚"><a href="#14、-Java-的四种引用，强弱软虚" class="headerlink" title="14、 Java 的四种引用，强弱软虚"></a>14、 Java 的四种引用，强弱软虚</h3><h4 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h4><p>强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
<h4 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h4><p>软引用在程序内存不足时，会被回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf 这个引用也是强引用，它是指向 SoftReference 这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向 new String(&quot;str&quot;) 的引用，也就是 SoftReference 类中 T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM 就会回收早先创建的对象。</p>
<h4 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h4><p>弱引用就是只要 JVM 垃圾回收器发现了它，就会将之回收，他的强度比软引用更低一点，弱引用的对象下一次 GC 的时候一定会被回收，而不管内存是否足够。使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>
<p><strong>可用场景：</strong>  Java 源码中的 <code>java.util.WeakHashMap</code>​ 中的 <code>key</code>​ 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM 会自动帮我处理它，这样我就不需要做其它操作。</p>
<h4 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h4><p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 <code>ReferenceQueue</code>​ 中。注意哦，其它引用是被 JVM 回收后才被传入 <code>ReferenceQueue</code>​ 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 <code>ReferenceQueue</code>​ ，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存</p>
<p>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。 <code>Object.finalize()</code>​ 虽然也可以做这类动作，但是这个方式即不安全又低效</p>
<p>上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用（ SoftReference 等）。</p>
<h3 id="15、-泛型常用特点"><a href="#15、-泛型常用特点" class="headerlink" title="15、 泛型常用特点"></a>15、 泛型常用特点</h3><p>泛型是 Java SE 1.5 之后的特性， 《Java 核心技术》中对泛型的定义是：</p>
<p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。</p>
<p>“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList 就是个泛型类，ArrayList作为集合可以存放各种元素，如 Integer， String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iniData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>
<p>使用泛型的好处？</p>
<p>以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了 Object 即可，添加的数据全部都可向上转型为 Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p>
<h3 id="16、-Java-创建对象有几种方式？"><a href="#16、-Java-创建对象有几种方式？" class="headerlink" title="16、 Java 创建对象有几种方式？"></a>16、 Java 创建对象有几种方式？</h3><h4 id="1、new-关键字"><a href="#1、new-关键字" class="headerlink" title="1、new 关键字"></a><strong>1、new 关键字</strong></h4><p>使用 new 关键字创建对象，这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的构造器（无参的和有参的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassName</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassName</span>();</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>当我们使用 <code>new</code>​ 创建了一个对象时，会在栈中创建 <code>myClass</code>​ 这个引用，并且在堆中开辟一块空间存放对象的值，然后让 <code>myClass</code>​ 这个引用指向堆中新建的 <code>ClassName</code>​ 对象的值；</li>
<li>不管每次创建的对象的值是否相同，每次用 <code>new</code>​ 创建对象时，在栈中创建的引用都是不一样的，即地址都是不一样的。</li>
</ul>
<h4 id="2、Class-newInstance"><a href="#2、Class-newInstance" class="headerlink" title="2、Class.newInstance"></a><strong>2、Class.newInstance</strong></h4><p>这是我们运用 <strong>反射</strong> 创建对象时最常用的方法。</p>
<p><code>Class</code>​ 类的 <code>newInstance</code>​ 使用的是类的 <code>public</code>​ 的 <strong>无参</strong> 构造方法。因此也就是说使用此方法创建对象的前提是必须有 <code>public</code>​ 的无参构造器才行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassName</span> <span class="variable">myClass</span> <span class="operator">=</span> ClassName.class.newInstance();</span><br><span class="line"><span class="type">ClassName</span> <span class="variable">myClass</span> <span class="operator">=</span> (ClassName)Class.foeName(<span class="string">&quot;ClassName&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure>
<h4 id="3、Constructor-newInstance"><a href="#3、Constructor-newInstance" class="headerlink" title="3、Constructor.newInstance"></a>3、Constructor.newInstance</h4><p>该方法和 <code>Class</code>​ 类的 <code>newInstance</code>​ 方法很像，但是比它强大很多。</p>
<p><code>java.lang.relect.Constructor</code>​ 类里也有一个 <code>newInstance</code>​ 方法可以创建对象。</p>
<p>我们可以通过这个 <code>newInstance</code>​ 方法调用 <strong>有参数</strong>（不再必须是无参）的和 <strong>私有的</strong> 构造函数（不再必须是 <code>public</code>​ ）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;ClassName&gt; constructor = ClassName.class.getConstructor();</span><br><span class="line"><span class="type">ClassName</span> <span class="variable">class</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>
<h4 id="两种-newInstance-方法的区别"><a href="#两种-newInstance-方法的区别" class="headerlink" title="两种 newInstance 方法的区别"></a>两种 newInstance 方法的区别</h4><ul>
<li><code>Class</code>​ 类位于 <code>java</code>​ 的 <code>lang</code>​ 包中，<br>​<code>Constructor</code>​ 是 <code>java</code>​ 反射机制的一部分</li>
<li><code>Class</code>​ 类的 <code>newInstance</code>​ 只能触发 <strong>无参数</strong> 的构造方法创建对象，<br>​<code>Constructor</code>​ 类的 <code>newInstance</code>​ 能触发 <strong>有参数</strong> 或者 <strong>任意参数</strong> 的构造方法来创建对象。</li>
<li><code>Class</code>​ 类的 <code>newInstance</code>​ 需要其构造方法是 <code>public</code>​ 的或者对调用方法可见的，<br>​<code>Constructor</code>​ 类的 <code>newInstance</code>​ 可以在特定环境下调用 <strong>私有构造方法</strong> 来创建对象。</li>
<li><code>Class</code>​ 类的 <code>newInstance</code>​ 抛出类构造函数的异常，<br>​<code>Constructor</code>​ 类的 <code>newInstance</code>​ 包装了一个 <code>InvocationTargetException</code>​ 异常。</li>
</ul>
<h4 id="4、Clone-方法"><a href="#4、Clone-方法" class="headerlink" title="4、Clone 方法"></a>4、Clone 方法</h4><p>无论何时我们调用一个对象的 <code>clone</code>​ 方法，<code>JVM</code>​ 就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用 <code>clone</code>​ 方法创建对象并不会调用任何构造函数。</p>
<p>要使用 <code>clone</code>​ 方法，我们必须先实现 <code>Cloneable</code>​ 接口并复写 <code>Object</code>​ 的 <code>clone</code>​ 方法（因为 <code>Object</code>​ 的这个方法是 <code>protected</code>​ 的，若不复写，外部也调用不了）。</p>
<p>public class ClassName implements Cloneable {<br>…<br>// 访问权限写为public，并且返回值写为myclass<br>@Override<br>public ClassName clone() throws CloneNotSupportedException {<br>return (ClassName) super.clone();<br>}<br>…<br>}</p>
<p>public class Main {<br>public static void main(String[] args) throws Exception {<br>ClassName myClass = new ClassName();<br>Object clone = myclass.clone();<br>//ClassName clone = (ClassName)myClass.clone();<br>}<br>}</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>clone()</code>​ 方法只会进行 <strong>浅复制</strong>，也就是说只会在栈中再创建一个引用指向原来的对象的值所处的堆空间中，堆中的对象的值还是原来的并没有重新创建；</li>
<li>使用 <code>clone()</code>​ 方法并不需要调用造函数</li>
</ul>
<h4 id="5、反序列化"><a href="#5、反序列化" class="headerlink" title="5、反序列化"></a>5、反序列化</h4><p>要想通过反序列化创建对象，就必须现将某个对象序列化</p>
<p><strong>概念：</strong></p>
<p>1.<strong>序列化：将</strong> <strong>​<code>java</code>​</strong>​ <strong>对象转化为字节流或字符流的过程</strong></p>
<p><strong>作用：</strong></p>
<p>（1）便于在网络上进行传输；</p>
<p>（2）将 <code>java</code>​ 字节序列永久保存在硬盘上，通常放在文件中，所以序列化也可以叫做持久化。</p>
<p>2.<strong>反序列化：将字节流或字符流对象转化成</strong> <strong>​<code>java</code>​</strong>​ <strong>对象的过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用反序列化创建对象</span></span><br><span class="line"><span class="comment"> * 当序列化和反序列化一个对象时，JVM会创建一个单独的对象。</span></span><br><span class="line"><span class="comment"> * 在反序列化时，JVM 创建对象并不会调用任何构造函数，</span></span><br><span class="line"><span class="comment"> * 为了反序列化一个对象，需要让我们的 ClassName 类实现 Serializable 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;F:\\Tests\\data.obj&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">//序列化过程</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">        objectOutputStream.writeObject(<span class="keyword">new</span> <span class="title class_">ClassName</span>());</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//反序列化过程</span></span><br><span class="line">		<span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line">		<span class="type">ClassName</span> <span class="variable">myClass</span> <span class="operator">=</span> (ClassName) inputStream.readObject();</span><br><span class="line">		inputStream.close();</span><br><span class="line"> </span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>备注</strong>：JDK 序列化、反序列化特别特别耗内存。</p>
<h4 id="Java-创建实例对象是不是必须要通过构造函数-构造器-构造方法？"><a href="#Java-创建实例对象是不是必须要通过构造函数-构造器-构造方法？" class="headerlink" title="Java 创建实例对象是不是必须要通过构造函数/构造器/构造方法？"></a>Java 创建实例对象是不是必须要通过构造函数/构造器/构造方法？</h4><div class="table-container">
<table>
<thead>
<tr>
<th>创建对象方式</th>
<th>是否调用了构造器</th>
</tr>
</thead>
<tbody>
<tr>
<td>new关键字</td>
<td>是</td>
</tr>
<tr>
<td>Class.newInstance</td>
<td>是</td>
</tr>
<tr>
<td>Constructor.newInstance</td>
<td>是</td>
</tr>
<tr>
<td>Clone</td>
<td>否</td>
</tr>
<tr>
<td>反序列化</td>
<td>否</td>
</tr>
</tbody>
</table>
</div>
<p><strong>答案：</strong> Java 创建实例对象，并不一定必须要调用构造函数/构造器/构造方法的。</p>
<h3 id="17-、有没有可能两个不相等的对象有相同的-hashcode"><a href="#17-、有没有可能两个不相等的对象有相同的-hashcode" class="headerlink" title="17 、有没有可能两个不相等的对象有相同的 hashcode"></a>17 、有没有可能两个不相等的对象有相同的 hashcode</h3><p>有可能.在产生 hash 冲突时,两个不相等的对象就会有相同的 hashcode 值。当 hash 冲突产生时,一般有以下几种方式来处理：</p>
<ul>
<li>拉链法：每个哈希表节点都有一个 next 指针，多个哈希表节点可以用 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储</li>
<li>开放定址法：一旦发生了冲突,就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</li>
<li>再哈希：又叫双哈希法，有多个不同的 Hash 函数。当发生冲突时，使用第二个，第三个….等哈希函数计算地址，直到无冲突</li>
</ul>
<h4 id="为什么-java-的指针压缩："><a href="#为什么-java-的指针压缩：" class="headerlink" title="为什么 java 的指针压缩："></a>为什么 java 的指针压缩：</h4><p>在 Java 中，指针压缩（Pointer Compression）是一种优化技术，用于减少对象指针的内存占用和提高内存访问效率。</p>
<p>在 32 位的 Java 虚拟机中，每个对象引用（指针）通常占用4字节的内存空间。然而，在实际的应用程序中，大部分的堆对象的内存地址范围并不需要使用整个 32 位空间。因此，指针压缩的目标是通过缩小指针的有效位数来减少内存消耗。</p>
<p>指针压缩的具体实现方式是通过将堆对象的内存地址空间划分为几个区域，其中一部分用于存储对象的数据，另一部分用于存储指针。指针压缩将指针的有效位数缩小，从而减少了指针的内存占用。例如，可以将指针大小压缩到3字节或2字节。</p>
<p>指针压缩的好处是可以减少内存消耗，并且在一定程度上提高内存访问效率。较小的指针大小意味着可以在更短的时间内读取或写入指针所指向的对象。此外，指针压缩还可以减少垃圾回收器的工作量，提高垃圾回收的效率。</p>
<p>需要注意的是，指针压缩只在 32 位的 Java 虚拟机中有效，因为在 64 位的虚拟机中，由于地址空间的扩展，指针大小通常为 8 字节，已经足够存储大量的对象引用。</p>
<h4 id="哈希冲突的产生原因及解决方法"><a href="#哈希冲突的产生原因及解决方法" class="headerlink" title="哈希冲突的产生原因及解决方法"></a>哈希冲突的产生原因及解决方法</h4><h5 id="哈希冲突的产生"><a href="#哈希冲突的产生" class="headerlink" title="哈希冲突的产生"></a>哈希冲突的产生</h5><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
<p>哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。</p>
<p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。（哈希表可以用来快速判断一个元素是否出现在集合里）</p>
<p>哈希法法的基本思想是：首先在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 f ，使得 p = f ( k ) ，f称为哈希函数。创建哈希表时，把关键字为 k 的元素直接存入地址为 f ( k ) 的单元；以后当查找关键字为 k 的元素时，再利用哈希函数计算出该元素的存储位置p = f ( k ) ，从而达到按关键字直接存取元素的目的。</p>
<p>当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1 ≠ k2 ，但 H（k1）= H（k2），这种现象称为冲突，此时称 k1 和 k2 为同义词。实际中，冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突。</p>
<p>综上所述，哈希法主要包括以下两方面的内容：</p>
<p>1）如何构造哈希函数</p>
<p>2）如何处理冲突</p>
<h5 id="产生哈希冲突的影响因素"><a href="#产生哈希冲突的影响因素" class="headerlink" title="产生哈希冲突的影响因素"></a><strong>产生哈希冲突的影响因素</strong></h5><p>装填因子（ 装填因子 = 数据总数 / 哈希表长 ）、哈希函数、处理冲突的方法</p>
<h5 id="哈希冲突解决办法"><a href="#哈希冲突解决办法" class="headerlink" title="哈希冲突解决办法"></a><strong>哈希冲突解决办法</strong></h5><h6 id="1、开放定址法（再散列法）"><a href="#1、开放定址法（再散列法）" class="headerlink" title="1、开放定址法（再散列法）"></a>1、开放定址法（再散列法）</h6><p>基本思想：当关键字 key 的哈希地址 p = H（key）出现冲突时，以 p 为基础，产生另一个哈希地址 p1，如果 p1 仍然冲突，再以 p 为基础，产生另一个哈希地址 p2 ，…，直到找出一个不冲突的哈希地址 pi ，将相应元素存入其中。</p>
<p>（1）线性探测</p>
<p>按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上往后加一个单位，直至不发生哈希冲突。</p>
<p>（2）再平方探测</p>
<p>按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则减 1 的平方个单位。随之是 2 的平方，3 的平方等等。直至不发生哈希冲突。</p>
<p>（3）伪随机探测</p>
<p>按顺序决定值时，如果某数据已经存在，通过随机函数随机生成一个数，在原来值的基础上加上随机数，直至不发生哈希冲突。</p>
<h6 id="2、链地址法（拉链法：HashMap-的哈希冲突解决方法）"><a href="#2、链地址法（拉链法：HashMap-的哈希冲突解决方法）" class="headerlink" title="2、链地址法（拉链法：HashMap 的哈希冲突解决方法）"></a>2、链地址法（拉链法：<strong>HashMap 的哈希冲突解决方法</strong>）</h6><p>基本思想：以数组为基本单元，将所有的哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。</p>
<p>链地址法适用于经常进行插入和删除的情况。</p>
<p><strong>优点：</strong></p>
<p>（1）拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p>
<p>（2）由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</p>
<p>（3）开放定址法为减少冲突，要求装填因子 α 较小，故当结点规模较大时会浪费很多空间。而拉链法中可取 α ≥ 1 ，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p>
<p>（4）在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p>
<p><strong>缺点：</strong></p>
<p>指针占用较大空间时，会造成空间浪费，若空间用于增大散列表规模进而提高开放地址法的效率。</p>
<h6 id="3、再哈希法"><a href="#3、再哈希法" class="headerlink" title="3、再哈希法"></a>3、再哈希法</h6><p>基本思想：同时构造多个不同的哈希函数，在发生冲突的时候再用另外一个哈希函数算出哈希值，直到算出的哈希值不同为止。</p>
<h6 id="4、建立公共溢出区"><a href="#4、建立公共溢出区" class="headerlink" title="4、建立公共溢出区"></a>4、建立公共溢出区</h6><p>基本思想：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。查表时，先去基本表查，查不到再去溢出区查找。</p>
<h3 id="18、深拷贝和浅拷贝的区别是什么？"><a href="#18、深拷贝和浅拷贝的区别是什么？" class="headerlink" title="18、深拷贝和浅拷贝的区别是什么？"></a>18、深拷贝和浅拷贝的区别是什么？</h3><ul>
<li>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，<strong>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象</strong></li>
<li>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，<strong>深拷贝把要复制的对象所引用的对象都复制了一遍</strong></li>
</ul>
<h3 id="19、final-有哪些用法"><a href="#19、final-有哪些用法" class="headerlink" title="19、final 有哪些用法?"></a>19、final 有哪些用法?</h3><ul>
<li>被 final 修饰的类不可以被继承</li>
<li>被 final 修饰的方法不可以被重写</li>
<li>被 final 修饰的变量不可以被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变</li>
<li>被 final 修饰的方法，JVM 会尝试将其内联，以提高运行效率</li>
<li>被 final 修饰的常量，在编译阶段会存入常量池中</li>
</ul>
<p>除此之外,编译器对 final 域要遵守的两个重排序规则更好：</p>
<p>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序，初次读一个包含final域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序.</p>
<h3 id="20、static-都有哪些用法？"><a href="#20、static-都有哪些用法？" class="headerlink" title="20、static 都有哪些用法？"></a>20、static 都有哪些用法？</h3><p>所有的人都知道 static 关键字这两个基本的用法：静态变量和静态方法。也就是被 static 所修饰的变量 / 方法都属于类的静态资源，类实例所共享.</p>
<p>除了静态变量和静态方法之外，static 也用于静态块，多用于初始化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line"> <span class="comment">//执行相关操作</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外 static 也多用于修饰内部类,此时称之为静态内部类</p>
<p>最后一种用法就是静态导包，即 <code>import static</code>​ .import static是在  JDK 1.5 之后引入的新特性，可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"> <span class="comment">//System.out.println(Math.sin(20));传统做法</span></span><br><span class="line"> System.out.println(sin(<span class="number">20</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21、-3-0-1-0-3-返回值是什么"><a href="#21、-3-0-1-0-3-返回值是什么" class="headerlink" title="21、 3  0.1  *==   0.3 返回值是什么"></a>21、 3 <em> 0.1  <em>*==</em></em>   0.3 返回值是什么</h3><p>false，因为有些浮点数不能完全精确的表示出来</p>
<h3 id="22、a-a-b-与-a-b-有什么区别吗"><a href="#22、a-a-b-与-a-b-有什么区别吗" class="headerlink" title="22、a = a + b 与 a + = b 有什么区别吗?"></a>22、a = a + b 与 a + = b 有什么区别吗?</h3><p><code>+=</code>​ 操作符会进行隐式自动类型转换，此处 a + = b 隐式的将加操作的结果类型强制转换为持有结果的类型,而 a = a + b 则不会自动进行类型转换。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// 报编译错误:cannot convert from int to byte</span></span><br><span class="line">b += a;</span><br></pre></td></tr></table></figure>
<p>以下代码是否有错,有的话怎么改？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s1= <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>有错误。short 类型在进行运算时会自动提升为 int 类型，也就是说 s1 + 1 的运算结果是 int 类型而 s1 是 short 类型，此时编译器会报错</p>
<p>正确写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s1= <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>+=</code>​ 操作符会对右边的表达式结果强转匹配左边的数据类型，所以没错</p>
<h3 id="23、try-catch-finally，try-里有-return-，finally-还执行么？"><a href="#23、try-catch-finally，try-里有-return-，finally-还执行么？" class="headerlink" title="23、try catch finally，try 里有 return ，finally 还执行么？"></a>23、try catch finally，try 里有 return ，finally 还执行么？</h3><p>执行，并且 finally 的执行早于 try 里面的 return。如果 finally 块中存在 return 语句，它会覆盖 try 块或 catch 块中的 return 语句，并成为最终的返回值。</p>
<p>结论：</p>
<p>1、不管有木有出现异常，finally 块中代码都会执行；</p>
<p>2、当 try 和 catch 中有 return 时，finally 仍然会执行；</p>
<p>3、finally 是在 return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管 finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在 finally 执行前确定的；</p>
<p>4、finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。</p>
<h3 id="24、Excption-与-Error-包结构"><a href="#24、Excption-与-Error-包结构" class="headerlink" title="24、Excption 与 Error 包结构"></a>24、Excption 与 Error 包结构</h3><p>Java 可抛出 ( Throwable ) 的结构分为三种类型：被检查的异常 ( CheckedException )，运行时异常 (RuntimeException )，错误( Error )</p>
<h4 id="1、运行时异常"><a href="#1、运行时异常" class="headerlink" title="1、运行时异常"></a>1、运行时异常</h4><p>定义：RuntimeException 及其子类都被称为运行时异常。</p>
<p>特点：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过 throws 声明抛出它”，也”没有用 try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的 ArithmeticException 异常，数组越界时产生的 IndexOutOfBoundsException异常，fail - fast 机制产生的 ConcurrentModificationException 异常（java.util 包下面的所有的集合类都是快速失败的，“快速失败”也就是 fail-fast，它是 Java 集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生 fail-fast 机制，这个错叫并发修改异常。Failsafe，java.util.concurrent 包下面的所有的类都是安全失败的，在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出 ConcurrentModificationException 异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是 ConcurrentHashMap 迭代器弱一致的表现。ConcurrentHashMap 的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与 Hashtable 和同步的 HashMap 一样了。）等，都属于运行时异常。</p>
<p>常见的五种运行时异常：</p>
<p>ClassCastException（类转换异常）</p>
<p>IndexOutOfBoundsException（数组越界）</p>
<p>NullPointerException（空指针异常）</p>
<p>ArrayStoreException（数据存储异常，操作数组是类型不一致）</p>
<p>BufferOverflowException</p>
<h4 id="2、被检查异常"><a href="#2、被检查异常" class="headerlink" title="2、被检查异常"></a>2、被检查异常</h4><p>定义：Exception 类本身，以及 Exception 的子类中除了”运行时异常”之外的其它子类都属于被检查异常。</p>
<p>特点：Java 编译器会检查它。 此类异常，要么通过 throws 进行声明抛出，要么通过 try - catch 进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException 就属于被检查异常。当通过 clone() 接口去克隆一个对象，而该对象对应的类没有实现 Cloneable 接口，就会抛出 CloneNotSupportedException 异常。被检查异常通常都是可以恢复的。 如：</p>
<p>IOException</p>
<p>FileNotFoundException</p>
<p>SQLException</p>
<p>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的 FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的 NullPointerException 。</p>
<h4 id="3、错误"><a href="#3、错误" class="headerlink" title="3、错误"></a>3、错误</h4><p>定义：Error 类及其子类。</p>
<p>特点：和运行时异常一样，编译器也不会对错误进行检查。</p>
<p>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError 就属于错误。出现这种错误会导致程序终止运行。</p>
<p>OutOfMemoryError、ThreadDeath。</p>
<p>Java 虚拟机规范规定 JVM 的内存分为了好几块，比如堆，栈，程序计数器，方法区等</p>
<h3 id="25、OOM-你遇到过哪些情况，SOF-你遇到过哪些情况"><a href="#25、OOM-你遇到过哪些情况，SOF-你遇到过哪些情况" class="headerlink" title="25、OOM 你遇到过哪些情况，SOF 你遇到过哪些情况"></a>25、OOM 你遇到过哪些情况，SOF 你遇到过哪些情况</h3><h4 id="OOM："><a href="#OOM：" class="headerlink" title="OOM："></a><strong>OOM</strong>：</h4><h5 id="1、OutOfMemoryError-异常"><a href="#1、OutOfMemoryError-异常" class="headerlink" title="1、OutOfMemoryError 异常"></a>1、OutOfMemoryError 异常</h5><p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemoryError ( OOM ) 异常的可能。</p>
<p>Java Heap 溢出：</p>
<p>一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。</p>
<p>java 堆用于存储对象实例，我们只要不断的创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p>
<p>出现这种异常，一般手段是先通过内存映像分析工具 ( 如 Eclipse Memory Analyzer ) 对 dump 出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏 ( Memory Leak ) 还是内存溢出 ( Memory Overflow )。</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GCRoots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。</p>
<p>如果不存在泄漏，那就应该检查虚拟机的参数  ( -Xmx 与 -Xms ) 的设置是否适当。</p>
<h5 id="2、虚拟机栈和本地方法栈溢出"><a href="#2、虚拟机栈和本地方法栈溢出" class="headerlink" title="2、虚拟机栈和本地方法栈溢出"></a>2、虚拟机栈和本地方法栈溢出</h5><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。</p>
<p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError异常</p>
<p>这里需要注意当栈的大小越大可分配的线程数就越少。</p>
<h5 id="3、运行时常量池溢出"><a href="#3、运行时常量池溢出" class="headerlink" title="3、运行时常量池溢出"></a>3、运行时常量池溢出</h5><p>异常信息：java.lang.OutOfMemoryError:PermGenspace</p>
<p>如果要向运行时常量池中添加内容，最简单的做法就是使用 String.intern() 这个 Native 方法。该方法的作用是：如果池中已经包含一个等于此 String 的字符串，则返回代表池中这个字符串的String对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此String 对象的引用。由于常量池分配在方法区内，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小，从而间接限制其中常量池的容量。</p>
<h5 id="4、方法区溢出"><a href="#4、方法区溢出" class="headerlink" title="4、方法区溢出"></a>4、方法区溢出</h5><p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的 class 对象没有被及时回收掉或者class信息占用的内存超过了我们配置。</p>
<p>异常信息：java.lang.OutOfMemoryError:PermGenspace</p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量 Class 的应用中，要特别注意这点。</p>
<h4 id="SOF（堆栈溢出-StackOverflow）："><a href="#SOF（堆栈溢出-StackOverflow）：" class="headerlink" title="SOF（堆栈溢出 StackOverflow）："></a>SOF（堆栈溢出 StackOverflow）：</h4><p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p>
<p>因为栈一般默认为 1 - 2 m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过 1 m 而导致溢出。</p>
<p>栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大。</p>
<h3 id="26、-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#26、-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h3><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h3 id="27、Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#27、Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="27、Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>27、Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h3 id="28、说说-Java-中-IO-流"><a href="#28、说说-Java-中-IO-流" class="headerlink" title="28、说说 Java 中 IO 流"></a>28、说说 Java 中 IO 流</h3><h4 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h4><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<p>InputStream / Reader：所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p>OutputStream / Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
<h3 id="29、-Java-IO-与-NIO-的区别（补充）"><a href="#29、-Java-IO-与-NIO-的区别（补充）" class="headerlink" title="29、 Java IO 与 NIO 的区别（补充）"></a>29、 Java IO 与 NIO 的区别（补充）</h3><p>NIO 即 New IO，这个库是在 JDK1.4 中才引入的。NIO 和 IO 有相同的作用和目的，但实现方式不同，NIO 主要用到的是块，所以 NIO 的效率要比 IO 高很多。在 Java API 中提供了两套 NIO，一套是针对标准输入输出 NIO，另一套就是网络编程 NIO。</p>
<h3 id="30、java-反射的作用于原理"><a href="#30、java-反射的作用于原理" class="headerlink" title="30、java 反射的作用于原理"></a>30、java 反射的作用于原理</h3><h4 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h4><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在 java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p>
<p><strong>这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</strong></p>
<h4 id="2、哪里会用到反射机制？"><a href="#2、哪里会用到反射机制？" class="headerlink" title="2、哪里会用到反射机制？"></a>2、哪里会用到反射机制？</h4><p>jdbc 就是典型的反射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载 MySQL 的驱动类</span></span><br></pre></td></tr></table></figure>
<p>这就是反射。如 hibernate，struts 等框架使用反射实现的。</p>
<h4 id="3、反射的实现方式："><a href="#3、反射的实现方式：" class="headerlink" title="3、反射的实现方式："></a>3、反射的实现方式：</h4><p>第一步：获取 Class 对象，有 4 中方法：</p>
<p>1）Class.forName (“类的路径”)；</p>
<p>2）类名.class</p>
<p>3）对象名.getClass()</p>
<p>4）基本类型的包装类，可以调用包装类的 Type 属性来获得该包装类的 Class 对象</p>
<h4 id="4、实现-Java-反射的类："><a href="#4、实现-Java-反射的类：" class="headerlink" title="4、实现 Java 反射的类："></a>4、实现 Java 反射的类：</h4><p>1）Class：表示正在运行的 Java 应用程序中的类和接口。注意： 所有获取对象的信息都需要 Class 类来实现。</p>
<p>2）Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</p>
<p>3）Constructor：提供关于类的单个构造方法的信息以及它的访问权限</p>
<p>4）Method：提供类或接口中某个方法的信息</p>
<h4 id="5、反射机制的优缺点："><a href="#5、反射机制的优缺点：" class="headerlink" title="5、反射机制的优缺点："></a>5、反射机制的优缺点：</h4><p><strong>优点：</strong></p>
<p>1）能够运行时动态获取类的实例，提高灵活性</p>
<p>2）与动态编译结合</p>
<p><strong>缺点：</strong></p>
<p>1）使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</p>
<p>解决方案：</p>
<p>1、通过 setAccessible ( true ) 关闭  JDK 的安全检查来提升反射速度；</p>
<p>2、多次创建一个类的实例时，有缓存会快很多</p>
<p>3、ReflectASM 工具类，通过字节码生成的方式加快反射速度</p>
<p>2）相对不安全，破坏了封装性（ 因为通过反射可以获得私有方法和属性 ）</p>
<h3 id="31、说说-List，Set，Map-三者的区别？"><a href="#31、说说-List，Set，Map-三者的区别？" class="headerlink" title="31、说说 List，Set，Map 三者的区别？"></a>31、说说 List，Set，Map 三者的区别？</h3><ul>
<li>List（对付顺序的好帮手）：List 接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li>Set（注重独一无二的性质）：不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li>Map（用 Key 来搜索的专家）：使用键值对存储。Map 会维护与 Key 有关联的值。两个 Key 可以引用相同的对象，但 Key 不能重复，典型的 Key 是 String 类型，但也可以是任何对象。</li>
</ul>
<h3 id="32、Object-有哪些常用方法？"><a href="#32、Object-有哪些常用方法？" class="headerlink" title="32、Object 有哪些常用方法？"></a>32、Object 有哪些常用方法？</h3><p>java.lang.Object</p>
<p><strong>clone</strong> <strong>方法</strong></p>
<p>保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常，深拷贝也需要实现 Cloneable，同时其成员变量为引用类型的也需要实现 Cloneable，然后重写 clone 方法。</p>
<p><strong>finalize</strong> <strong>方法</strong></p>
<p>该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方法。</p>
<p><strong>equals</strong> <strong>方法</strong></p>
<p>该方法使用频率非常高。一般 equals 和 == 是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。</p>
<p><strong>hashCode</strong> <strong>方法</strong></p>
<p>该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法，这个方法在一些具有哈希功能的 Collection 中用到。</p>
<p>一般必须满足 obj1.equals(obj2) == true 。可以推出 obj1.hashCode() == obj2.hashCode() ，但是 hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>
<p>JDK 1.6、1.7  默认是返回随机数；</p>
<p>JDK 1.8  默认是通过和当前线程有关的一个随机数 + 三个确定值，运用 Marsaglia’s xorshift scheme 随机数算法得到的一个随机数。</p>
<p><strong>wait</strong> <strong>方法</strong></p>
<p>配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait() 方法一直等待，直到获得锁或者被中断。wait ( long timeout ) 设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>
<p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<ol>
<li>其他线程调用了该对象的 notify 方法；</li>
<li>其他线程调用了该对象的 notifyAll 方法；</li>
<li>其他线程调用了 interrupt 中断该线程；</li>
<li>时间间隔到了。</li>
</ol>
<p>此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。</p>
<p><strong>notify</strong> <strong>方法</strong></p>
<p>配合 synchronized 使用，该方法唤醒在该对象上<strong>等待队列</strong>中的某个线程（同步队列中的线程是给抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。</p>
<p><strong>notifyAll</strong> <strong>方法</strong></p>
<p>配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程。</p>
<p><strong>总结</strong></p>
<p>只要把上面几个方法熟悉就可以了，toString 和 getClass 方法可以不用去讨论它们。该题目考察的是对 Object 的熟悉程度，平时用的很多方法并没看其定义但是也在用，比如说：wait() 方法，equals() 方法等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class Object is the root of the class hierarchy.Every class has Object as a</span><br><span class="line">superclass. All objects, including arrays, implement the methods of this class.</span><br></pre></td></tr></table></figure>
<p>大致意思：Object 是所有类的根，是所有类的父类，所有对象包括数组都实现了 Object 的方法。</p>
<h3 id="33、获取一个类-Class-对象的方式有哪些？"><a href="#33、获取一个类-Class-对象的方式有哪些？" class="headerlink" title="33、获取一个类 Class 对象的方式有哪些？"></a>33、获取一个类 Class 对象的方式有哪些？</h3><p>搞清楚类对象和实例对象，但都是对象。</p>
<p>第一种：通过类对象的 getClass() 方法获取，细心点的都知道，这个 getClass 是 Object 类里面的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="comment">//clazz就是一个User的类对象</span></span><br><span class="line">Class&lt;?&gt; clazz=user.getClass()</span><br></pre></td></tr></table></figure>
<p>第二种：通过类的静态成员表示，每个类都有隐含的静态成员 class。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//clazz就是一个User的类对象</span></span><br><span class="line">Class&lt;?&gt; clazz=User.class;</span><br></pre></td></tr></table></figure>
<p>第三种：通过 Class 类的静态方法 forName() 方法获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.tian.User&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="34、用过-ArrayList-吗？说一下它有什么特点？"><a href="#34、用过-ArrayList-吗？说一下它有什么特点？" class="headerlink" title="34、用过 ArrayList 吗？说一下它有什么特点？"></a>34、<strong>用过</strong> <strong>ArrayList</strong> 吗？说一下它有什么特点？</h3><p>Java 集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小。</p>
<p>底层是使用数组实现，添加元素。</p>
<p>如果 add ( o ) ，添加到的是数组的尾部，如果要增加的数据量很大，应该使用 ensureCapacity() 方法，该方法的作用是预先设置 ArrayList 的大小，这样可以大大提高初始化速度。</p>
<p>如果使用 add ( int , o ) ，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制。</p>
<p>高并发的情况下，线程不安全。多个线程同时操作 ArrayList，会引发不可预知的异常或错误。</p>
<p>ArrayList 实现了 Cloneable 接口，标识着它可以被复制。注意：ArrayList 里面的 clone() 复制其实是浅复制。</p>
<p><strong>有数组了为什么还要搞个</strong> <strong>ArrayList</strong> <strong>呢</strong></p>
<p>通常我们在使用的时候，如果在不明确要插入多少数据的情况下，普通数组就很尴尬了，因为你不知道需要初始化数组大小为多少，而 ArrayList 可以使用默认的大小，当元素个数到达一定程度后，会自动扩容。</p>
<p>可以这么来理解：我们常说的数组是定死的数组，ArrayList 却是动态数组</p>
<h3 id="35、说说什么是-fail-fast-？"><a href="#35、说说什么是-fail-fast-？" class="headerlink" title="35、说说什么是 fail - fast ？"></a>35、说说什么是 fail - fast ？</h3><p>fail - fast 机制是 Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail - fast 事件。</p>
<p>例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail - fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。</p>
<p>解决办法：建议使用“ java.util.concurrent 包下的类” 去取代 “ java.util 包下的类”。</p>
<p>可以这么理解：在遍历之前，把 modCount 记下来 expectModCount，后面 expectModCount 去和 modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出 ConcurrentModificationException 异常。</p>
<h3 id="36、HashMap-中的-key-我们可以使用任何类作为-key-吗？"><a href="#36、HashMap-中的-key-我们可以使用任何类作为-key-吗？" class="headerlink" title="36、HashMap 中的 key 我们可以使用任何类作为 key 吗？"></a>36、HashMap 中的 key 我们可以使用任何类作为 key 吗？</h3><p>平时可能大家使用的最多的就是使用 String 作为 HashMap 的 key，但是现在我们想使用某个自定义类作为 HashMap 的 key，那就需要注意以下几点：</p>
<ul>
<li>如果类重写了 equals 方法，它也应该重写 hashCode 方法。</li>
<li>类的所有实例需要遵循与 equals 和 hashCode 相关的规则。</li>
<li>如果一个类没有使用 equals，你不应该在 hashCode 中使用它。</li>
<li>咱们自定义 key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<h3 id="37、HashMap-的长度为什么是-2-的-N-次方呢？"><a href="#37、HashMap-的长度为什么是-2-的-N-次方呢？" class="headerlink" title="37、HashMap 的长度为什么是 2 的 N 次方呢？"></a>37、HashMap 的长度为什么是 2 的 N 次方呢？</h3><p>为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。</p>
<p>我们首先可能会想到 % 取模的操作来实现。</p>
<p>下面是回答的重点哟：</p>
<p>取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说 hash % length == hash &amp; ( length - 1 ) 的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 &amp; ，相对于 % 能够提高运算效率。</p>
<p>这就是为什么 HashMap 的长度需要 2 的 N 次方了</p>
<h3 id="38、HashMap-与-ConcurrentHashMap-的异同"><a href="#38、HashMap-与-ConcurrentHashMap-的异同" class="headerlink" title="38、HashMap 与 ConcurrentHashMap 的异同"></a>38、HashMap 与 ConcurrentHashMap 的异同</h3><ol>
<li>都是 key - value 形式的存储数据；</li>
<li>HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；</li>
<li>HashMap 底层数据结构是数组 + 链表（ JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</li>
<li>HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩容；</li>
<li>ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry，Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized来保证并发安全进行实现。</li>
</ol>
<h3 id="39、红黑树有哪几个特征？"><a href="#39、红黑树有哪几个特征？" class="headerlink" title="39、红黑树有哪几个特征？"></a>39、红黑树有哪几个特征？</h3><ul>
<li>每个节点是黑色或红色</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色（指向空的叶子节点）</li>
<li>如果一个叶子节点是红色，那么其子节点必须都是黑色的</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li>
</ul>
<h3 id="40、说说你平时是怎么处理-Java-异常的"><a href="#40、说说你平时是怎么处理-Java-异常的" class="headerlink" title="40、说说你平时是怎么处理 Java 异常的"></a>40、<strong>说说你平时是怎么处理</strong> <strong>Java</strong> 异常的</h3><p>try - catch - finally</p>
<ul>
<li>try 块负责监控可能出现异常的代码</li>
<li>catch 块负责捕获可能出现的异常，并进行处理</li>
<li>finally 块负责清理各种资源，不管是否出现异常都会执行</li>
<li>其中 try 块是必须的，catch 和 finally 至少存在一个标准异常处理流程</li>
</ul>
<p>在开发过程中会使用到自定义异常，在通常情况下，程序很少会自己抛出异常，因为异常的类名通常也包含了该异常的有用信息，所以在选择抛出异常的时候，应该选择合适的异常类，从而可以明确地描述该异常情况，所以这时候往往都是自定义异常。</p>
<p>自定义异常通常是通过继承 java.lang.Exception 类，如果想自定义 Runtime 异常的话，可以继承 java.lang.RuntimeException 类，实现一个无参构造和一个带字符串参数的有参构造方法。</p>
<p>在业务代码里，可以针对性的使用自定义异常。比如说：该用户不具备某某权限、余额不足等</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>基础篇</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://lunanorth.github.io/posts/6314.html">https://lunanorth.github.io/posts/6314.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>捞月亮の小北</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-23</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-08-23</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/wallhaven-jx793p.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/62535.html" title="MySQL篇"><img class="cover" src="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/wallhaven-qzmlj5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL篇</div></div></a></div><div class="next-post pull-right"><a href="/posts/9905.html" title="如何让自己早睡"><img class="cover" src="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/cat-cloud-sky-zombie-2313032.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何让自己早睡</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">捞月亮の小北</div><div class="author-info__description">言念君子 ，温其如玉</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" href="https://lunanorth.github.io/"><i class="fab fa-github"></i><span>剑气长安</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">请不要把陌生人的些许善意，视为珍稀的瑰宝，却把身边亲近人的全部付出，当做天经地义的事情，对其视而不见!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-Java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-text">1、 Java 语言有哪些特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2、面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E3%80%81%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E5%B0%81%E8%A3%85%E7%B1%BB"><span class="toc-text">3  、八种基本数据类型的大小，以及他们的封装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">4、标识符的命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81instanceof-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">5、instanceof 关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Java-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-text">6、Java 自动装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7、 重载和重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81equals-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8、equals 与 &#x3D;&#x3D; 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Hashcode-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">9、Hashcode 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">10、String、StringBuffer 和 StringBuilder 的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81ArrayList-%E5%92%8C-linkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11、ArrayList 和 linkedList 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12、HashMap 和 HashTable 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%B8%A4%E8%80%85%E7%88%B6%E7%B1%BB%E4%B8%8D%E5%90%8C"><span class="toc-text">1、两者父类不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E5%90%8C"><span class="toc-text">2、对外提供的接口不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9-null-%E7%9A%84%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C"><span class="toc-text">3、对 null 的支持不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E5%90%8C"><span class="toc-text">4、安全性不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%AF%8F%E6%AC%A1%E6%89%A9%E5%85%85%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%90%8C"><span class="toc-text">5、初始容量大小和每次扩充容量大小不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%AE%A1%E7%AE%97-hash-%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-text">6、计算 hash 值的方法不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C"><span class="toc-text">7. 迭代器内部实现不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81-Collection-%E5%8C%85%E7%BB%93%E6%9E%84%E4%B8%8E-Collections-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13、 Collection 包结构与 Collections 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81-Java-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%BA%E5%BC%B1%E8%BD%AF%E8%99%9A"><span class="toc-text">14、 Java 的四种引用，强弱软虚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-text">1、强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-text">2、软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-text">3、弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-text">4、虚引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81-%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9"><span class="toc-text">15、 泛型常用特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81-Java-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">16、 Java 创建对象有几种方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81new-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1、new 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Class-newInstance"><span class="toc-text">2、Class.newInstance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Constructor-newInstance"><span class="toc-text">3、Constructor.newInstance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D-newInstance-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">两种 newInstance 方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Clone-%E6%96%B9%E6%B3%95"><span class="toc-text">4、Clone 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">5、反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BF%85%E9%A1%BB%E8%A6%81%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%84%E9%80%A0%E5%99%A8-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">Java 创建实例对象是不是必须要通过构造函数&#x2F;构造器&#x2F;构造方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E3%80%81%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84-hashcode"><span class="toc-text">17 、有没有可能两个不相等的对象有相同的 hashcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-java-%E7%9A%84%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9%EF%BC%9A"><span class="toc-text">为什么 java 的指针压缩：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">哈希冲突的产生原因及解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-text">哈希冲突的产生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0"><span class="toc-text">产生哈希冲突的影响因素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">哈希冲突解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95%EF%BC%88%E5%86%8D%E6%95%A3%E5%88%97%E6%B3%95%EF%BC%89"><span class="toc-text">1、开放定址法（再散列法）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%88%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%9AHashMap-%E7%9A%84%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">2、链地址法（拉链法：HashMap 的哈希冲突解决方法）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-text">3、再哈希法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA"><span class="toc-text">4、建立公共溢出区</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">18、深拷贝和浅拷贝的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81final-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95"><span class="toc-text">19、final 有哪些用法?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81static-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-text">20、static 都有哪些用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81-3-0-1-0-3-%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">21、 3  0.1  *&#x3D;&#x3D;   0.3 返回值是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81a-a-b-%E4%B8%8E-a-b-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97"><span class="toc-text">22、a &#x3D; a + b 与 a + &#x3D; b 有什么区别吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81try-catch-finally%EF%BC%8Ctry-%E9%87%8C%E6%9C%89-return-%EF%BC%8Cfinally-%E8%BF%98%E6%89%A7%E8%A1%8C%E4%B9%88%EF%BC%9F"><span class="toc-text">23、try catch finally，try 里有 return ，finally 还执行么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81Excption-%E4%B8%8E-Error-%E5%8C%85%E7%BB%93%E6%9E%84"><span class="toc-text">24、Excption 与 Error 包结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-text">1、运行时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%A2%AB%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="toc-text">2、被检查异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%94%99%E8%AF%AF"><span class="toc-text">3、错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81OOM-%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%8CSOF-%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5"><span class="toc-text">25、OOM 你遇到过哪些情况，SOF 你遇到过哪些情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OOM%EF%BC%9A"><span class="toc-text">OOM：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81OutOfMemoryError-%E5%BC%82%E5%B8%B8"><span class="toc-text">1、OutOfMemoryError 异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-text">2、虚拟机栈和本地方法栈溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA"><span class="toc-text">3、运行时常量池溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-text">4、方法区溢出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SOF%EF%BC%88%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA-StackOverflow%EF%BC%89%EF%BC%9A"><span class="toc-text">SOF（堆栈溢出 StackOverflow）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81-%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%82%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">27、Java 序列化中如果有些字段不想进行序列化，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E8%AF%B4%E8%AF%B4-Java-%E4%B8%AD-IO-%E6%B5%81"><span class="toc-text">28、说说 Java 中 IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D"><span class="toc-text">Java 中 IO 流分为几种?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81-Java-IO-%E4%B8%8E-NIO-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">29、 Java IO 与 NIO 的区别（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81java-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%8E%9F%E7%90%86"><span class="toc-text">30、java 反射的作用于原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">1、定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%93%AA%E9%87%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">2、哪里会用到反射机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">3、反射的实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%AE%9E%E7%8E%B0-Java-%E5%8F%8D%E5%B0%84%E7%9A%84%E7%B1%BB%EF%BC%9A"><span class="toc-text">4、实现 Java 反射的类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">5、反射机制的优缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E8%AF%B4%E8%AF%B4-List%EF%BC%8CSet%EF%BC%8CMap-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">31、说说 List，Set，Map 三者的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81Object-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">32、Object 有哪些常用方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB-Class-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">33、获取一个类 Class 对象的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81%E7%94%A8%E8%BF%87-ArrayList-%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">34、用过 ArrayList 吗？说一下它有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF-fail-fast-%EF%BC%9F"><span class="toc-text">35、说说什么是 fail - fast ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81HashMap-%E4%B8%AD%E7%9A%84-key-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E7%B1%BB%E4%BD%9C%E4%B8%BA-key-%E5%90%97%EF%BC%9F"><span class="toc-text">36、HashMap 中的 key 我们可以使用任何类作为 key 吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84-N-%E6%AC%A1%E6%96%B9%E5%91%A2%EF%BC%9F"><span class="toc-text">37、HashMap 的长度为什么是 2 的 N 次方呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81HashMap-%E4%B8%8E-ConcurrentHashMap-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">38、HashMap 与 ConcurrentHashMap 的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-text">39、红黑树有哪几个特征？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%B9%B3%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86-Java-%E5%BC%82%E5%B8%B8%E7%9A%84"><span class="toc-text">40、说说你平时是怎么处理 Java 异常的</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 捞月亮の小北</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">言念君子 ，温其如玉<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23livb5sxAzXC5FAOj',
      clientSecret: '901c2a65d4b136d295133e9a8176b8650d782c41',
      repo: 'blog-gitalk',
      owner: 'LunaNorth',
      admin: ['LunaNorth'],
      id: '2197888275a7723b3734caf101fbc622',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><canvas id="universe"></canvas><script async data-pjax src="/js/universe.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '81efe4afadcd49fc93bcfb1aa5d42b3c';
  var gaud_map_key = 'ea946ee5b69e4a4fe76909e6537b883d';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8ebfad52.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/08/08/pkzZNWD.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8ebfad52.html&quot;);" href="javascript:void(0);" alt="">轻语时光</a><div class="blog-slider__text">我大抵是真的眼花了，竟把一个人的落日，看成了两个人的黄昏</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8ebfad52.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/56917.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/09/19/pAKRcZV.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/56917.html&quot;);" href="javascript:void(0);" alt="">百天打卡</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/56917.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37820.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/sy14.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-24</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37820.html&quot;);" href="javascript:void(0);" alt="">博客日志</a><div class="blog-slider__text">对该博客进行一个简单的记录</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37820.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/facab7a2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/08/11/pASTNY8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/facab7a2.html&quot;);" href="javascript:void(0);" alt="">我在人间凑数的日子</a><div class="blog-slider__text">什么家国仇恨浩然正气的，都不要急。先挑起清风明月，杨柳依依和草长莺飞</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/facab7a2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5413be0e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/sy06.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-02-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5413be0e.html&quot;);" href="javascript:void(0);" alt="">健身日记</a><div class="blog-slider__text">请不要把陌生人的些许善意，视为珍稀的瑰宝，却把身边亲近人的全部付出，当做天经地义的事情，对其视而不见。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5413be0e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/17639.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://testingcf.jsdelivr.net/gh/LunaNorth/img-cloud/images/18.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/17639.html&quot;);" href="javascript:void(0);" alt="">Tag Plugins Plus 的日常使用</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/17639.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>